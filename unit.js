// Generated by CoffeeScript 1.7.1
var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

define(['inject', 'p2'], function(inject, p2) {
  var Unit;
  return Unit = (function() {
    function Unit(entity, n) {
      this.cohere = __bind(this.cohere, this);
      this.form = __bind(this.form, this);
      this.align = __bind(this.align, this);
      this.separate = __bind(this.separate, this);
      this.step = __bind(this.step, this);
      this.e = entity;
      this.n = n;
    }

    Unit.prototype.step = function() {
      this.separate();
      this.align();
      this.form();
      return this.cohere();
    };

    Unit.prototype.separate = function() {
      var averagerepulsion, force, istouched;
      averagerepulsion = [0, 0];
      inject.one('each by distance')(this.e.phys.b.position, 25, (function(_this) {
        return function(d, e) {
          var diff;
          if (e === _this.e || (e.ai == null)) {
            return;
          }
          diff = [0, 0];
          p2.vec2.sub(diff, _this.e.phys.b.position, e.phys.b.position);
          p2.vec2.normalize(diff, diff);
          return p2.vec2.add(averagerepulsion, averagerepulsion, diff);
        };
      })(this));
      istouched = p2.vec2.len(averagerepulsion) !== 0;
      inject.one('abs stat')(this.e, {
        istouched: istouched
      });
      if (!istouched) {
        return;
      }
      inject.one('scale to max velocity')(averagerepulsion);
      force = inject.one('calculate steering')(this.e.phys.b.velocity, averagerepulsion);
      p2.vec2.scale(force, force, 2);
      return inject.one('apply force')(this.e, force);
    };

    Unit.prototype.align = function() {
      var averagedirection, count, force;
      averagedirection = [0, 0];
      count = 0;
      inject.one('each by distance')(this.e.phys.b.position, 100, (function(_this) {
        return function(d, e) {
          if (e === _this.e || (e.ai == null)) {
            return;
          }
          p2.vec2.add(averagedirection, averagedirection, e.phys.b.velocity);
          return count++;
        };
      })(this));
      if (p2.vec2.len(averagedirection) === 0) {
        return;
      }
      inject.one('scale to max velocity')(averagedirection);
      force = inject.one('calculate steering')(this.e.phys.b.velocity, averagedirection);
      p2.vec2.scale(force, force, 0.4);
      return inject.one('apply force')(this.e, force);
    };

    Unit.prototype.form = function() {
      var d, dist, distances, first, force, mag, next, rotate, target, target1, target2, target3, target4, targets, _i, _len;
      this.e.target = null;
      this.e.targets = null;
      distances = [];
      inject.one('each by distance')(this.e.phys.b.position, 60, (function(_this) {
        return function(d, e) {
          if (e === _this.e || (e.ai == null)) {
            return;
          }
          return distances.push({
            d: d,
            e: e
          });
        };
      })(this));
      if (distances.length === 0) {
        return;
      }
      distances.sort((function(_this) {
        return function(a, b) {
          return a.d - b.d;
        };
      })(this));
      targets = [];
      first = distances[0];
      if (distances.length === 1) {
        target = [0, 0];
        p2.vec2.sub(target, this.e.phys.b.position, first.e.phys.b.position);
        p2.vec2.normalize(target, target);
        p2.vec2.scale(target, target, 32);
        p2.vec2.add(target, target, first.e.phys.b.position);
        targets.push(target);
      } else {
        next = {
          d: 120,
          e: null
        };
        for (_i = 0, _len = distances.length; _i < _len; _i++) {
          d = distances[_i];
          if (d.e === first.e) {
            continue;
          }
          dist = p2.vec2.dist(d.e.phys.b.position, first.e.phys.b.position);
          if (dist < next.d) {
            next.d = dist;
            next.e = d.e;
          }
        }
        target = [0, 0];
        p2.vec2.sub(target, first.e.phys.b.position, next.e.phys.b.position);
        p2.vec2.normalize(target, target);
        p2.vec2.scale(target, target, 32);
        target1 = [0, 0];
        p2.vec2.add(target1, first.e.phys.b.position, target);
        target2 = [0, 0];
        p2.vec2.sub(target2, first.e.phys.b.position, target);
        rotate = inject.one('anticlockwise')(target);
        target3 = [0, 0];
        p2.vec2.add(target3, first.e.phys.b.position, rotate);
        target4 = [0, 0];
        p2.vec2.sub(target4, first.e.phys.b.position, rotate);
        targets.push(target1);
        targets.push(target2);
        targets.push(target3);
        targets.push(target4);
      }
      targets = targets.filter(function(t) {
        var _j, _len1;
        for (_j = 0, _len1 = distances.length; _j < _len1; _j++) {
          d = distances[_j];
          dist = p2.vec2.dist(t, d.e.phys.b.position);
          if (dist <= 24) {
            return false;
          }
        }
        return true;
      });
      targets = targets.map((function(_this) {
        return function(t) {
          return {
            d: p2.vec2.dist(t, _this.e.phys.b.position),
            t: t
          };
        };
      })(this));
      targets.sort((function(_this) {
        return function(a, b) {
          return a.d - b.d;
        };
      })(this));
      this.e.targets = targets;
      if (targets.length === 0) {
        return;
      }
      this.e.target = targets[0].t;
      mag = [0, 0];
      p2.vec2.sub(mag, this.e.target, this.e.phys.b.position);
      inject.one('limit to max velocity')(mag);
      force = inject.one('calculate steering')(this.e.phys.b.velocity, mag);
      p2.vec2.scale(force, force, 0.5);
      return inject.one('apply force')(this.e, force);
    };

    Unit.prototype.cohere = function() {
      var averageposition, count, force, iscommunity, targetvelocity;
      averageposition = [0, 0];
      count = 0;
      inject.one('each by distance')(this.e.phys.b.position, 100, (function(_this) {
        return function(d, e) {
          if (e === _this.e || (e.ai == null)) {
            return;
          }
          p2.vec2.add(averageposition, averageposition, e.phys.b.position);
          return count++;
        };
      })(this));
      inject.one('abs stat')(this.e, {
        iscommunity: count > 0
      });
      iscommunity = count > 0;
      if (p2.vec2.len(averageposition) === 0) {
        return;
      }
      p2.vec2.scale(averageposition, averageposition, 1 / count);
      targetvelocity = inject.one('calculate seeking')(this.e.phys.b.position, averageposition);
      force = inject.one('calculate steering')(this.e.phys.b.velocity, targetvelocity);
      p2.vec2.scale(force, force, 0.1);
      return inject.one('apply force')(this.e, force);
    };

    return Unit;

  })();
});
