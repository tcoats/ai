// Generated by CoffeeScript 1.7.1
define(['inject', 'p2'], function(inject, p2) {
  return inject.bind('square group', function(entity, scale) {
    var d, dist, distances, first, force, mag, next, rotate, target, target1, target2, target3, target4, targets, _i, _len;
    entity.target = null;
    entity.targets = null;
    distances = [];
    inject.one('each by distance')(entity.phys.b.position, 60, function(d, e) {
      if (e === entity || (e.ai == null)) {
        return;
      }
      return distances.push({
        d: d,
        e: e
      });
    });
    if (distances.length === 0) {
      return;
    }
    distances.sort(function(a, b) {
      return a.d - b.d;
    });
    targets = [];
    first = distances[0];
    if (distances.length === 1) {
      target = [0, 0];
      p2.vec2.sub(target, entity.phys.b.position, first.e.phys.b.position);
      p2.vec2.normalize(target, target);
      p2.vec2.scale(target, target, 32);
      p2.vec2.add(target, target, first.e.phys.b.position);
      targets.push(target);
    } else {
      next = {
        d: 120,
        e: null
      };
      for (_i = 0, _len = distances.length; _i < _len; _i++) {
        d = distances[_i];
        if (d.e === first.e) {
          continue;
        }
        dist = p2.vec2.dist(d.e.phys.b.position, first.e.phys.b.position);
        if (dist < next.d) {
          next.d = dist;
          next.e = d.e;
        }
      }
      target = [0, 0];
      p2.vec2.sub(target, first.e.phys.b.position, next.e.phys.b.position);
      p2.vec2.normalize(target, target);
      p2.vec2.scale(target, target, 32);
      target1 = [0, 0];
      p2.vec2.add(target1, first.e.phys.b.position, target);
      target2 = [0, 0];
      p2.vec2.sub(target2, first.e.phys.b.position, target);
      rotate = inject.one('anticlockwise')(target);
      target3 = [0, 0];
      p2.vec2.add(target3, first.e.phys.b.position, rotate);
      target4 = [0, 0];
      p2.vec2.sub(target4, first.e.phys.b.position, rotate);
      targets.push(target1);
      targets.push(target2);
      targets.push(target3);
      targets.push(target4);
    }
    targets = targets.filter(function(t) {
      var _j, _len1;
      for (_j = 0, _len1 = distances.length; _j < _len1; _j++) {
        d = distances[_j];
        dist = p2.vec2.dist(t, d.e.phys.b.position);
        if (dist <= 24) {
          return false;
        }
      }
      return true;
    });
    targets = targets.map(function(t) {
      return {
        d: p2.vec2.dist(t, entity.phys.b.position),
        t: t
      };
    });
    targets.sort(function(a, b) {
      return a.d - b.d;
    });
    entity.targets = targets;
    if (targets.length === 0) {
      return;
    }
    entity.target = targets[0].t;
    mag = [0, 0];
    p2.vec2.sub(mag, entity.target, entity.phys.b.position);
    inject.one('limit to max velocity')(mag);
    force = inject.one('calculate steering')(entity.phys.b.velocity, mag);
    p2.vec2.scale(force, force, scale);
    return inject.one('apply force')(entity, force);
  });
});
